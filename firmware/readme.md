# STM32L031 Low Frequency Oscillator

### Based on the LFO used in the [variable slope filter/phaser](http://jhaible.com/legacy/varislope_filter_phaser/varislope_filter_phaser.html) project by the great Jurgen Haible.

---

### Features:

- Three analog control inputs, all ranging from 0v to +3.3v:
    - Frequency: sets the frequency of the LFO, ranges from quite slow to a few tens of Hertz.
    - Wave shape: smoothly crossfades between triangle, sine, square, and sample & hold waveforms.
    - Level: a simple output level control.

- One crossfaded analog output, in the range 0v to +2v.

---

### Brief overview of the algorithm:
- The three control signals are read by the ADC and stored in a buffer via DMA.
- The frequency control is scaled by using a lookup table as an exponential converter.
- Wave shape and level controls are linear.
- A timer configured as a periodic stopwatch sets the sample rate for the LFO.
- The LFO uses a simple form of [direct digital synthesis](https://www.digikey.com/en/articles/the-basics-of-direct-digital-synthesizers-ddss) as its core.
- The LFO waveforms are independently generated:
    - The triangle wave is derived directly from the phase accumulator.
    - The sine wave uses a lookup table.
    - The square wave is also a simple transformation of the raw phase accumulator.
    - A random sample & hold signal is generated via a [Linear Feedback Shift Register](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3639) and sampled at twice the base LFO frequency (this makes it "feel right").
- A wave scanner then smoothly crossfades between the above shapes, in the above order. This creates a fun and intuitive transition from smooth, to choppy, to chaotic LFO shapes.
- Since the LFO is very low frequency and only used for modulation purposes, no attempts to mitigate aliasing are attempted.
- The final analog output is created by a cheap 12 bit SPI DAC.
- Lookup tables are generated by a python script located in the `utils` directory.

---

### Prerequisites for building and flashing the project:
- [arm-none-eabi toolchain](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads)
- [GNU make](https://www.gnu.org/software/make/)
- [st-link utility](https://www.st.com/en/development-tools/stsw-link004.html)
- A physical st-link device. I use an old [Nucleo board](https://www.st.com/en/evaluation-tools/stm32-nucleo-boards.html).
- If you have a different preferred method of flashing STM32 chips (openocd, etc) then feel free to go wild.

### To build the project:
- `$ make`

### To flash an STM32 chip connected to an st-link programmer via the SWD header:
- `$ make write`

---

### Firmware directory organization:
- `third_party` contains the STM32 supplied CMSIS header-only files, assembly startup routine, and linker script.
- `BSP` is a very basic "Board Support Package", this module initializes and modifies the various stm32 peripherals used by the system.
- `lib` contains user library files.
- `src` contains the main application files.
- `utils` contains non-c language utility source files such as a python lookup table generating script.
- `bin` is the destination for output files generated by the build process.
